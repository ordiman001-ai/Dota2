<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Mini-Dota: –¢—Ä–æ–Ω–Ω–∞—è –í–æ–π–Ω–∞ (–ò—Å–ø—Ä–∞–≤–ª–µ–Ω–æ)</title>
    <!-- Tailwind CSS CDN -->
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@100..900&display=swap');
        body {
            font-family: 'Inter', sans-serif;
            background-color: #1a202c; /* –¢–µ–º–Ω—ã–π —Ñ–æ–Ω */
        }
        #gameContainer {
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 20px;
        }
        canvas {
            border: 4px solid #4a5568;
            border-radius: 12px;
            background-color: #0d1117; /* –¢–µ–º–Ω—ã–π —Ñ–æ–Ω –∫–∞—Ä—Ç—ã */
            cursor: crosshair;
            box-shadow: 0 10px 15px rgba(0, 0, 0, 0.5);
        }
        .ui-panel {
            background-color: #2d3748;
            border-radius: 8px;
            padding: 10px;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.3);
            margin-top: 10px;
        }
        .ability-button {
            width: 50px;
            height: 50px;
            border-radius: 8px;
            font-size: 1.2rem;
            font-weight: bold;
            color: #fff;
            border: 2px solid #a0aec0;
            background-color: #4a5568;
            transition: all 0.1s;
            position: relative;
            cursor: pointer;
        }
        .ability-button:hover:not(:disabled) {
            background-color: #636b77;
            border-color: #fff;
            transform: translateY(-1px);
        }
        .ability-button:disabled {
            cursor: not-allowed;
            opacity: 0.5;
        }
        .cooldown-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.7);
            color: white;
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 1rem;
            border-radius: 6px;
        }
        .cast-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(255, 255, 0, 0.5); /* –ñ–µ–ª—Ç—ã–π –∏–Ω–¥–∏–∫–∞—Ç–æ—Ä –∫–∞—Å—Ç–∞ */
            color: black;
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 1rem;
            border-radius: 6px;
        }
    </style>
</head>
<body class="min-h-screen flex items-center justify-center">

    <div id="gameContainer" class="w-full max-w-4xl">
        <h1 class="text-3xl font-bold text-yellow-400 mb-4">Mini-Dota: –¢—Ä–æ–Ω–Ω–∞—è –í–æ–π–Ω–∞</h1>

        <!-- –û—Å–Ω–æ–≤–Ω–æ–π UI: –°—Ç–∞—Ç—É—Å, –ó–æ–ª–æ—Ç–æ, –ú–∞–≥–∞–∑–∏–Ω -->
        <div class="flex justify-between w-full mb-4 space-x-4">

            <!-- –ü–∞–Ω–µ–ª—å –°—Ç–∞—Ç—É—Å–∞ –ì–µ—Ä–æ—è -->
            <div class="ui-panel flex-1 text-white">
                <h2 class="text-xl font-semibold mb-2 text-blue-300">–ì–µ—Ä–æ–π: –°–≤–µ—Ç–ª—ã–π –ú–∞–≥</h2>
                <div id="heroStats" class="space-y-1 text-sm">
                    <!-- –°—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞ –æ–±–Ω–æ–≤–ª—è–µ—Ç—Å—è JS -->
                </div>
            </div>

            <!-- –ú–∞–≥–∞–∑–∏–Ω -->
            <div id="shop" class="ui-panel w-64 text-white">
                <h2 class="text-xl font-semibold mb-2 text-green-300">–ú–∞–≥–∞–∑–∏–Ω (–ë–∞–∑–∞)</h2>
                <div id="shopItems" class="space-y-2">
                    <!-- –ü—Ä–µ–¥–º–µ—Ç—ã –º–∞–≥–∞–∑–∏–Ω–∞ –∑–∞–ø–æ–ª–Ω—è—é—Ç—Å—è JS -->
                </div>
            </div>

        </div>

        <!-- Canvas Game World -->
        <canvas id="gameCanvas" width="800" height="400"></canvas>

        <!-- –ü–∞–Ω–µ–ª—å –°–ø–æ—Å–æ–±–Ω–æ—Å—Ç–µ–π -->
        <div class="ui-panel flex justify-center space-x-4 mt-4">
            <h3 class="text-lg font-medium text-gray-300 mr-4">–°–ø–æ—Å–æ–±–Ω–æ—Å—Ç–∏:</h3>
            <button class="ability-button bg-green-600 border-green-400" id="abilityQ" data-ability="Q" title="Q: –ò—Å—Ü–µ–ª–µ–Ω–∏–µ (–ú–≥–Ω–æ–≤–µ–Ω–Ω–æ–µ)">Q</button>
            <button class="ability-button bg-red-800 border-red-400" id="abilityW" data-ability="W" title="W: –ú–µ—Ç–µ–æ—Ä (–£—Ä–æ–Ω –ø–æ –∫—Ä–∏–ø–∞–º –≤ –æ–±–ª–∞—Å—Ç–∏, 0.5—Å –∫–∞—Å—Ç)">W</button>
            <button class="ability-button bg-purple-600 border-purple-400" id="abilityE" data-ability="E" title="E: –ü—Ä–∏–∑—ã–≤ –°–æ—é–∑–Ω–∏–∫–æ–≤ (–ú–≥–Ω–æ–≤–µ–Ω–Ω–æ–µ)">E</button>
            <button class="ability-button bg-cyan-600 border-cyan-400" id="abilityR" data-ability="R" title="R: –£–ª—å—Ç–∏–º–∞—Ç–∏–≤–Ω—ã–π –£–¥–∞—Ä (–£—Ä–æ–Ω –ø–æ –±–∞—à–Ω—è–º, 0.5—Å –∫–∞—Å—Ç)">R</button>
            <button class="ability-button bg-orange-500 border-orange-400" id="abilityD" data-ability="D" title="D: –ü—Ä–∏–∑—ã–≤ –°–∏–ª—å–Ω–æ–≥–æ –°–æ—é–∑–Ω–∏–∫–∞ (–¢—Ä–µ–±—É–µ—Ç—Å—è –ø—Ä–µ–¥–º–µ—Ç)" disabled>D</button>
        </div>

        <!-- –ü–∞–Ω–µ–ª—å —Å–æ–æ–±—â–µ–Ω–∏–π -->
        <div id="messageBox" class="ui-panel w-full text-center text-red-400 font-bold hidden"></div>

        <!-- –ö–Ω–æ–ø–∫–∞ —Ä–µ—Å—Ç–∞—Ä—Ç–∞ -->
        <button id="restartButton" onclick="restartGame()" class="mt-4 bg-yellow-500 hover:bg-yellow-600 text-gray-900 font-bold py-2 px-4 rounded transition duration-150 hidden">–ù–∞—á–∞—Ç—å –Ω–æ–≤—É—é –∏–≥—Ä—É</button>

    </div>

    <script>
        // –ì–ª–æ–±–∞–ª—å–Ω—ã–µ –ø–µ—Ä–µ–º–µ–Ω–Ω—ã–µ –¥–ª—è Canvas
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const MAP_WIDTH = canvas.width;
        const MAP_HEIGHT = canvas.height;
        let lastTime = 0;
        let gameActive = true;
        let gameTime = 0; // –ò–°–ü–†–ê–í–õ–ï–ù–ò–ï: –£–Ω–∏—Ñ–∏—Ü–∏—Ä–æ–≤–∞–Ω–Ω—ã–π —Å—á–µ—Ç—á–∏–∫ –≤—Ä–µ–º–µ–Ω–∏ –∏–≥—Ä—ã –≤ –º—Å
        
        // --- –ö–æ–Ω—Å—Ç–∞–Ω—Ç—ã –∏–≥—Ä—ã ---
        const LANE_Y = MAP_HEIGHT / 2;
        const SPAWN_INTERVAL = 10000; // 10 —Å–µ–∫—É–Ω–¥
        let lastSpawnTime = 0;
        const TEAM_RADIANT = 'radiant'; // –°–≤–µ—Ç
        const TEAM_DIRE = 'dire';   // –¢—å–º–∞
        const SIGHT_RANGE = 500; // –û–±–ª–∞—Å—Ç—å –≤–∏–¥–∏–º–æ—Å—Ç–∏ –∫—Ä–∏–ø–æ–≤

        // --- –ü–æ–∑–∏—Ü–∏–∏ –Ω–∞ –∫–∞—Ä—Ç–µ ---
        const RADIANT_SPAWN = { x: 50, y: LANE_Y };
        const DIRE_SPAWN = { x: MAP_WIDTH - 50, y: LANE_Y };
        
        // –ì–ª–∞–≤–Ω—ã–µ —Å—Ç—Ä—É–∫—Ç—É—Ä—ã (–¢—Ä–æ–Ω)
        const RADIANT_THRONE = { x: 30, y: LANE_Y, hp: 3000, maxHp: 3000, size: 40, color: '#38a169', team: TEAM_RADIANT, isThrone: true, radius: 20 };
        const DIRE_THRONE = { x: MAP_WIDTH - 30, y: LANE_Y, hp: 3000, maxHp: 3000, size: 40, color: '#e53e3e', team: TEAM_DIRE, isThrone: true, radius: 20 };
        
        // –ò—Å—Ö–æ–¥–Ω—ã–µ –±–∞—à–Ω–∏ (T1 –∏ T2)
        const INITIAL_TOWERS = [
            // –ë–∞—à–Ω–∏ –°–≤–µ—Ç–∞
            { x: 150, y: LANE_Y, hp: 1500, range: 150, dmg: 50, team: TEAM_RADIANT },
            { x: 300, y: LANE_Y, hp: 1500, range: 150, dmg: 50, team: TEAM_RADIANT },
            // –ë–∞—à–Ω–∏ –¢—å–º—ã
            { x: MAP_WIDTH - 150, y: LANE_Y, hp: 1500, range: 150, dmg: 50, team: TEAM_DIRE },
            { x: MAP_WIDTH - 300, y: LANE_Y, hp: 1500, range: 150, dmg: 50, team: TEAM_DIRE },
        ];
        
        // --- –ò–≥—Ä–æ–≤—ã–µ –∫–æ–ª–ª–µ–∫—Ü–∏–∏ ---
        let entities = [];
        let projectiles = [];
        let towers = []; // –¢–æ–ª—å–∫–æ T1 –∏ T2
        let delayedEffects = [];
        let hero;

        // --- –ö–ª–∞—Å—Å—ã ---

        class Vector2 {
            constructor(x, y) {
                this.x = x;
                this.y = y;
            }
            distanceTo(other) {
                return Math.hypot(this.x - other.x, this.y - other.y);
            }
            normalize() {
                const len = this.length();
                if (len === 0) return new Vector2(0, 0);
                return new Vector2(this.x / len, this.y / len);
            }
            length() {
                return Math.hypot(this.x, this.y);
            }
        }

        class Entity {
            constructor({ x, y, team, hp, maxHp, moveSpeed, radius, attackDamage, attackRange, goldValue, expValue }) {
                this.position = new Vector2(x, y);
                this.team = team;
                this.hp = hp;
                this.maxHp = maxHp;
                this.moveSpeed = moveSpeed;
                this.radius = radius;
                this.attackDamage = attackDamage;
                this.attackRange = attackRange;
                this.goldValue = goldValue || 0;
                this.expValue = expValue || 0;
                this.target = null;
                this.attackCooldown = 0;
                this.isDead = false;
            }

            takeDamage(damage) {
                this.hp -= damage;
                if (this.hp <= 0) {
                    this.hp = 0;
                    return true;
                }
                return false;
            }

            drawHealthBar() {
                const barWidth = this.radius * 2;
                const barHeight = 4;
                const healthRatio = this.hp / this.maxHp;

                ctx.fillStyle = 'black';
                ctx.fillRect(this.position.x - this.radius, this.position.y - this.radius - barHeight - 2, barWidth, barHeight);

                // –¶–≤–µ—Ç –ø–æ–ª–æ—Å—ã –∑–¥–æ—Ä–æ–≤—å—è
                let color = '#ecc94b'; // –ù–µ–π—Ç—Ä–∞–ª—å–Ω—ã–π
                if (this.team === TEAM_RADIANT) color = '#48bb78';
                else if (this.team === TEAM_DIRE) color = '#f56565';
                
                ctx.fillStyle = color;

                ctx.fillRect(this.position.x - this.radius, this.position.y - this.radius - barHeight - 2, barWidth * healthRatio, barHeight);
            }
        }

        class Creep extends Entity {
            constructor({ x, y, team, type, laneTarget }) {
                const stats = type === 'melee' ?
                    { hp: 500, maxHp: 500, moveSpeed: 30, radius: 8, attackDamage: 15, attackRange: 50, goldValue: 20, expValue: 50 } :
                    { hp: 300, maxHp: 300, moveSpeed: 35, radius: 8, attackDamage: 20, attackRange: 150, goldValue: 25, expValue: 60 };

                super({ ...stats, x, y, team });
                this.type = type;
                this.laneTarget = laneTarget || (team === TEAM_RADIANT ? DIRE_SPAWN : RADIANT_SPAWN);
            }

            findTarget() {
                const enemyCreeps = entities.filter(e => e.team !== this.team && e.hp > 0 && (e instanceof Creep || e instanceof AllyCreep));
                const enemyHero = entities.find(e => e.team !== this.team && e.hp > 0 && e instanceof Hero);
                const enemyTowers = towers.filter(t => t.team !== this.team && t.hp > 0);
                const enemyThrone = this.team === TEAM_RADIANT ? DIRE_THRONE : RADIANT_THRONE;
                
                // 1. –ü—Ä–∏–æ—Ä–∏—Ç–µ—Ç: –ö—Ä–∏–ø—ã –ø—Ä–æ—Ç–∏–≤–Ω–∏–∫–∞ –≤ —Ä–∞–¥–∏—É—Å–µ –≤–∏–¥–∏–º–æ—Å—Ç–∏ (SIGHT_RANGE)
                let targets = enemyCreeps.filter(e => this.position.distanceTo(e.position) < SIGHT_RANGE);
                if (targets.length > 0) {
                    return targets.sort((a, b) => this.position.distanceTo(a.position) - this.position.distanceTo(b.position))[0];
                }
                
                // 2. –ü—Ä–∏–æ—Ä–∏—Ç–µ—Ç: –ì–µ—Ä–æ–π –ø—Ä–æ—Ç–∏–≤–Ω–∏–∫–∞ –≤ —Ä–∞–¥–∏—É—Å–µ –≤–∏–¥–∏–º–æ—Å—Ç–∏
                if (enemyHero && this.position.distanceTo(enemyHero.position) < SIGHT_RANGE) {
                    return enemyHero;
                }
                
                // 3. –ü—Ä–∏–æ—Ä–∏—Ç–µ—Ç: –ë–ª–∏–∂–∞–π—à–∞—è –ë–∞—à–Ω—è/–¢—Ä–æ–Ω
                targets = [...enemyTowers, enemyThrone].filter(t => this.position.distanceTo(t.position || t) < SIGHT_RANGE * 2); 
                if (targets.length > 0) {
                    return targets.sort((a, b) => this.position.distanceTo(a.position || a) - this.position.distanceTo(b.position || b))[0];
                }
                
                return null;
            }

            update(dt) {
                this.attackCooldown = Math.max(0, this.attackCooldown - dt);

                this.target = this.findTarget();

                if (this.target) {
                    const targetPos = this.target.position || this.target;
                    const targetRadius = this.target.radius || 0;
                    const dist = this.position.distanceTo(targetPos);

                    if (dist < this.attackRange + targetRadius) {
                        // –ê—Ç–∞–∫–∞
                        if (this.attackCooldown === 0) {
                            this.attack(this.target);
                            this.attackCooldown = 1500;
                        }
                    } else {
                        // –î–≤–∏–∂–µ–Ω–∏–µ –∫ —Ü–µ–ª–∏
                        const direction = new Vector2(
                            targetPos.x - this.position.x,
                            targetPos.y - this.position.y
                        ).normalize();
                        this.position.x += direction.x * this.moveSpeed * (dt / 1000);
                        this.position.y += direction.y * direction.y * this.moveSpeed * (dt / 1000);
                    }
                } else {
                    // –î–≤–∏–∂–µ–Ω–∏–µ –ø–æ –ª–∏–Ω–∏–∏ –∫ —Ç–æ—á–∫–µ —Å–ø–∞–≤–Ω–∞ –ø—Ä–æ—Ç–∏–≤–Ω–∏–∫–∞ (–ø–æ —É–º–æ–ª—á–∞–Ω–∏—é)
                    const dist = this.position.distanceTo(this.laneTarget);
                    if (dist > 5) {
                        const direction = new Vector2(
                            this.laneTarget.x - this.position.x,
                            this.laneTarget.y - this.position.y
                        ).normalize();
                        this.position.x += direction.x * this.moveSpeed * (dt / 1000);
                        this.position.y += direction.y * this.moveSpeed * (dt / 1000);
                    }
                }
            }

            attack(target) {
                const isThrone = target.isThrone;
                let isDead = false;

                if (isThrone) {
                    target.hp -= this.attackDamage;
                    isDead = target.hp <= 0;
                } else {
                    isDead = target.takeDamage(this.attackDamage);
                }

                if (isDead) {
                    this.target = null;
                }

                projectiles.push({
                    start: new Vector2(this.position.x, this.position.y),
                    end: new Vector2((target.position || target).x, (target.position || target).y),
                    color: this.team === TEAM_RADIANT ? '#48bb78' : '#f56565',
                    time: 0,
                    duration: 100
                });
            }

            draw() {
                ctx.fillStyle = this.team === TEAM_RADIANT ? '#48bb78' : this.team === TEAM_DIRE ? '#f56565' : '#ecc94b';
                ctx.beginPath();
                ctx.arc(this.position.x, this.position.y, this.radius, 0, Math.PI * 2);
                ctx.fill();
                this.drawHealthBar();
            }
        }
        
        // –ö—Ä–∏–ø—ã-—Å–æ—é–∑–Ω–∏–∫–∏ (E) - –∞—Ç–∞–∫—É—é—Ç –±–∞—à–Ω–∏
        class AllyCreep extends Creep {
            constructor({ x, y }) {
                // –ü—Ä–∏–æ—Ä–∏—Ç–µ—Ç: Tower -> Throne -> Creep/Hero
                super({ 
                    x, y, team: TEAM_RADIANT, type: 'melee', 
                    laneTarget: DIRE_SPAWN // –î–≤–∏–≥–∞—Ç—å—Å—è –∫ –¢—å–º–µ
                });
                this.maxHp = 400; this.hp = 400;
                this.attackDamage = 35;
                this.radius = 9;
                this.moveSpeed = 40;
                this.goldValue = 0;
            }
            
            findTarget() {
                // 1. –ù–∞–π—Ç–∏ –±–ª–∏–∂–∞–π—à—É—é –≤—Ä–∞–∂–µ—Å–∫—É—é –ë–∞—à–Ω—é/–¢—Ä–æ–Ω
                const targets = towers.filter(t => t.team === TEAM_DIRE && t.hp > 0).concat([DIRE_THRONE]);
                
                let closestStructure = targets.sort((a, b) => this.position.distanceTo(a.position || a) - this.position.distanceTo(b.position || b))[0];
                
                // –ï—Å–ª–∏ —Å—Ç—Ä—É–∫—Ç—É—Ä–∞ –≤ —Ä–∞–¥–∏—É—Å–µ 1000, –∞—Ç–∞–∫—É–µ–º –µ–µ
                if (closestStructure && this.position.distanceTo(closestStructure.position || closestStructure) < 1000) return closestStructure;
                
                // –ï—Å–ª–∏ —Å—Ç—Ä—É–∫—Ç—É—Ä –Ω–µ—Ç –∏–ª–∏ –æ–Ω–∏ –¥–∞–ª–µ–∫–æ, –∏—Å–ø–æ–ª—å–∑—É–µ–º —Å—Ç–∞–Ω–¥–∞—Ä—Ç–Ω—É—é –ª–æ–≥–∏–∫—É (–ö—Ä–∏–ø—ã -> –ì–µ—Ä–æ–π)
                return super.findTarget();
            }
            
            draw() {
                ctx.fillStyle = '#9f7aea'; // –§–∏–æ–ª–µ—Ç–æ–≤—ã–π
                ctx.beginPath();
                ctx.arc(this.position.x, this.position.y, this.radius, 0, Math.PI * 2);
                ctx.fill();
                this.drawHealthBar();
            }
        }
        
        // –°–∏–ª—å–Ω—ã–π –ö—Ä–∏–ø-—Å–æ—é–∑–Ω–∏–∫ (D) - –∞—Ç–∞–∫—É–µ—Ç –±–∞—à–Ω–∏
        class StrongAllyCreep extends AllyCreep {
            constructor({ x, y }) {
                super({ x, y });
                // –£–¥–≤–æ–µ–Ω–Ω—ã–µ —Ö–∞—Ä–∞–∫—Ç–µ—Ä–∏—Å—Ç–∏–∫–∏ –æ—Ç –±–∞–∑–æ–≤—ã—Ö –∫—Ä–∏–ø–æ–≤ (melee: 500hp, 15dmg)
                this.maxHp = 1000; this.hp = 1000;
                this.attackDamage = 30;
                this.radius = 12;
                this.moveSpeed = 35;
            }
            
            draw() {
                // –û—Ä–∞–Ω–∂–µ–≤—ã–π
                ctx.fillStyle = '#f6ad55'; 
                ctx.beginPath();
                ctx.arc(this.position.x, this.position.y, this.radius, 0, Math.PI * 2);
                ctx.fill();
                
                ctx.strokeStyle = '#fff';
                ctx.lineWidth = 2;
                ctx.stroke();
                
                this.drawHealthBar();
            }
        }

        // –ù–µ–π—Ç—Ä–∞–ª—å–Ω—ã–π –ö—Ä–∏–ø
        class NeutralCreep extends Entity {
            constructor({ x, y }) {
                super({ 
                    x, y, team: 'neutral',
                    hp: 800, maxHp: 800, moveSpeed: 0, radius: 15,
                    attackDamage: 40, attackRange: 100, goldValue: 100, expValue: 150 
                });
                this.aggroRange = 250;
                this.initialPosition = new Vector2(x, y);
            }
            
            findTarget() {
                // –ò—â–µ–º –±–ª–∏–∂–∞–π—à–µ–≥–æ –≥–µ—Ä–æ—è –∏–ª–∏ –∫—Ä–∏–ø–∞ (–ª—é–±–æ–π –∫–æ–º–∞–Ω–¥—ã) –≤ —Ä–∞–¥–∏—É—Å–µ –∞–≥—Ä–µ—Å—Å–∏–∏
                const potentialTargets = entities.filter(e => 
                    (e instanceof Creep || e instanceof AllyCreep || e instanceof Hero) && 
                    e.hp > 0 && 
                    this.position.distanceTo(e.position) < this.aggroRange
                );
                
                if (potentialTargets.length === 0) return null;

                // –ù–∞—Ö–æ–¥–∏–º –±–ª–∏–∂–∞–π—à—É—é —Ü–µ–ª—å
                return potentialTargets.sort((a, b) => this.position.distanceTo(a.position) - this.position.distanceTo(b.position))[0];
            }
            
            update(dt) {
                this.attackCooldown = Math.max(0, this.attackCooldown - dt);
                this.target = this.findTarget();

                if (this.target) {
                    const targetPos = this.target.position;
                    const dist = this.position.distanceTo(targetPos);
                    
                    if (dist < this.attackRange + this.target.radius) {
                         // –ê—Ç–∞–∫–∞
                        if (this.attackCooldown === 0) {
                            this.attack(this.target);
                            this.attackCooldown = 1500;
                        }
                    }
                }
                // –ù–µ–π—Ç—Ä–∞–ª—ã –Ω–µ –¥–≤–∏–≥–∞—é—Ç—Å—è
                this.position = this.initialPosition; 
            }
            
            attack(target) {
                target.takeDamage(this.attackDamage);

                projectiles.push({
                    start: new Vector2(this.position.x, this.position.y),
                    end: new Vector2(target.position.x, target.position.y),
                    color: '#ecc94b',
                    time: 0,
                    duration: 100
                });
            }

            draw() {
                // –ñ–µ–ª—Ç—ã–π –¢—Ä–µ—É–≥–æ–ª—å–Ω–∏–∫
                ctx.fillStyle = '#ecc94b'; 
                ctx.beginPath();
                ctx.moveTo(this.position.x - this.radius, this.position.y + this.radius);
                ctx.lineTo(this.position.x + this.radius, this.position.y + this.radius);
                ctx.lineTo(this.position.x, this.position.y - this.radius);
                ctx.closePath();
                ctx.fill();
                this.drawHealthBar();
            }
        }


        class Tower {
            constructor({ x, y, hp, range, dmg, team }) {
                this.position = new Vector2(x, y);
                this.hp = hp;
                this.maxHp = hp;
                this.range = range;
                this.dmg = dmg;
                this.team = team;
                this.radius = 12;
                this.attackCooldown = 0;
            }
            
            takeDamage(damage) {
                this.hp -= damage;
                if (this.hp <= 0) {
                    this.hp = 0;
                    return true;
                }
                return false;
            }

            update(dt) {
                this.attackCooldown = Math.max(0, this.attackCooldown - dt);

                if (this.hp <= 0) return;

                // –ü—Ä–∏–æ—Ä–∏—Ç–µ—Ç –±–∞—à–Ω–∏: –ö—Ä–∏–ø—ã > –ì–µ—Ä–æ–π
                const enemiesInRange = entities.filter(e => e.team !== this.team && this.position.distanceTo(e.position) < this.range);

                let target = enemiesInRange.find(e => e instanceof Creep || e instanceof AllyCreep); // –ö—Ä–∏–ø—ã + –°–æ—é–∑–Ω–∏–∫–∏
                if (!target) {
                    target = enemiesInRange.find(e => e instanceof Hero); // –ì–µ—Ä–æ–π
                }

                if (target && this.attackCooldown === 0) {
                    this.attack(target);
                    this.attackCooldown = 800;
                }
            }

            attack(target) {
                const isDead = target.takeDamage(this.dmg);

                projectiles.push({
                    start: new Vector2(this.position.x, this.position.y),
                    end: new Vector2(target.position.x, target.position.y),
                    color: '#a0aec0',
                    time: 0,
                    duration: 150
                });
            }

            draw() {
                const color = this.team === TEAM_RADIANT ? '#3182ce' : '#9b2c2c';
                ctx.fillStyle = color;
                ctx.fillRect(this.position.x - 10, this.position.y - 10, 20, 20);
                ctx.strokeStyle = color;
                ctx.lineWidth = 2;
                ctx.strokeRect(this.position.x - 12, this.position.y - 12, 24, 24);

                // –û—Ç—Ä–∏—Å–æ–≤–∫–∞ –∑–¥–æ—Ä–æ–≤—å—è
                const barWidth = 30;
                const barHeight = 6;
                const healthRatio = this.hp / this.maxHp;

                ctx.fillStyle = 'black';
                ctx.fillRect(this.position.x - barWidth / 2, this.position.y - 20, barWidth, barHeight);
                ctx.fillStyle = healthRatio > 0.3 ? '#48bb78' : '#f56565';
                ctx.fillRect(this.position.x - barWidth / 2, this.position.y - 20, barWidth * healthRatio, barHeight);
            }
        }

        class Hero extends Entity {
            constructor({ x, y }) {
                super({
                    x, y, team: TEAM_RADIANT,
                    hp: 500, maxHp: 500, moveSpeed: 100, radius: 10,
                    attackDamage: 30, attackRange: 150,
                    goldValue: 0, expValue: 0
                });
                this.mana = 300;
                this.maxMana = 300;
                this.gold = 600;
                this.level = 1;
                this.exp = 0;
                this.expToNextLevel = 100;
                this.respawnTimer = 0;
                this.respawnTime = 3000; // 3 —Å–µ–∫—É–Ω–¥—ã

                this.targetPosition = new Vector2(x, y);

                // –ù–æ–≤—ã–µ —Å–≤–æ–π—Å—Ç–≤–∞ –¥–ª—è –º–µ—Ö–∞–Ω–∏–∫–∏ –∑–∞–¥–µ—Ä–∂–∫–∏ –∫–∞—Å—Ç–∞ (W, R)
                this.isCasting = false; 
                this.castTimer = 0;
                this.pendingCast = null; // { key: string, target: Vector2 }

                this.abilities = {
                    Q: { cd: 0, maxCd: 10000, manaCost: 50, desc: '–ü–æ–ª–Ω–æ–µ –ò—Å—Ü–µ–ª–µ–Ω–∏–µ (–ú–≥–Ω–æ–≤–µ–Ω–Ω—ã–π)' },
                    W: { cd: 0, maxCd: 15000, manaCost: 100, desc: '–ú–µ—Ç–µ–æ—Ä (0.5—Å –ö–∞—Å—Ç)' }, 
                    E: { cd: 0, maxCd: 20000, manaCost: 120, desc: '–ü—Ä–∏–∑—ã–≤ –°–æ—é–∑–Ω–∏–∫–æ–≤ (–ú–≥–Ω–æ–≤–µ–Ω–Ω–æ–µ)' },
                    R: { cd: 0, maxCd: 30000, manaCost: 200, desc: '–£–ª—å—Ç–∏–º–∞—Ç–∏–≤–Ω—ã–π –£–¥–∞—Ä (0.5—Å –ö–∞—Å—Ç)' },
                    D: { cd: 0, maxCd: 60000, manaCost: 250, desc: '–°–∏–ª—å–Ω—ã–π –°–æ—é–∑–Ω–∏–∫', available: false }
                };

                this.items = [];
            }
            
            takeDamage(damage) {
                this.hp -= damage;
                if (this.hp <= 0 && !this.isDead) {
                    this.isDead = true;
                    this.respawnTimer = this.respawnTime;
                    showMessage('–ì–µ—Ä–æ–π —É–±–∏—Ç! –í–æ–∑—Ä–æ–∂–¥–µ–Ω–∏–µ —á–µ—Ä–µ–∑ 3 —Å–µ–∫—É–Ω–¥—ã.', 'text-red-500');
                    return true;
                }
                return false;
            }


            update(dt) {
                if (this.isDead) {
                    this.respawnTimer = Math.max(0, this.respawnTimer - dt);
                    if (this.respawnTimer === 0) {
                        this.isDead = false;
                        this.hp = this.maxHp;
                        this.mana = this.maxMana;
                        this.position = new Vector2(RADIANT_THRONE.x, RADIANT_THRONE.y); 
                        this.targetPosition = new Vector2(RADIANT_THRONE.x, RADIANT_THRONE.y);
                        showMessage('–ì–µ—Ä–æ–π –≤–æ–∑—Ä–æ–¥–∏–ª—Å—è!', 'text-blue-500');
                    }
                    return;
                }

                // --- –õ–û–ì–ò–ö–ê –ö–ê–°–¢–ê –° –ó–ê–î–ï–†–ñ–ö–û–ô (0.5—Å) ---
                if (this.isCasting) {
                    this.castTimer = Math.max(0, this.castTimer - dt);

                    if (this.castTimer === 0 && this.pendingCast) {
                        // FIX: –°–æ—Ö—Ä–∞–Ω—è–µ–º –∫–ª—é—á —Å–ø–æ—Å–æ–±–Ω–æ—Å—Ç–∏ –ø–µ—Ä–µ–¥ –æ–±–Ω—É–ª–µ–Ω–∏–µ–º this.pendingCast
                        // –≠–¢–û –ò–°–ü–†–ê–í–õ–Ø–ï–¢ –û–®–ò–ë–ö–£ "Cannot read properties of null (reading 'key')"
                        const castKey = this.pendingCast.key;
                        
                        // –í—ã–ø–æ–ª–Ω–µ–Ω–∏–µ —Å–ø–æ—Å–æ–±–Ω–æ—Å—Ç–∏ –ø–æ—Å–ª–µ –∑–∞–¥–µ—Ä–∂–∫–∏
                        this.executeCast(castKey, this.pendingCast.target);
                        this.isCasting = false;
                        this.pendingCast = null; 
                        
                        // –ò—Å–ø–æ–ª—å–∑—É–µ–º —Å–æ—Ö—Ä–∞–Ω–µ–Ω–Ω—ã–π –∫–ª—é—á –¥–ª—è —Å–æ–æ–±—â–µ–Ω–∏—è
                        showMessage(`–°–ø–æ—Å–æ–±–Ω–æ—Å—Ç—å ${castKey} –ø—Ä–∏–º–µ–Ω–µ–Ω–∞!`, 'text-green-400');
                    }
                    // –ì–µ—Ä–æ–π –Ω–µ –¥–≤–∏–≥–∞–µ—Ç—Å—è –∏ –Ω–µ –∞—Ç–∞–∫—É–µ—Ç, –ø–æ–∫–∞ isCasting = true
                    return; 
                }
                // --- –ö–û–ù–ï–¶ –õ–û–ì–ò–ö–ò –ö–ê–°–¢–ê ---

                // –í–æ—Å—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω–∏–µ HP/Mana
                this.hp = Math.min(this.maxHp, this.hp + 5 * (dt / 1000));
                this.mana = Math.min(this.maxMana, this.mana + 3 * (dt / 1000));

                // –û–±–Ω–æ–≤–ª–µ–Ω–∏–µ –ø–µ—Ä–µ–∑–∞—Ä—è–¥–∫–∏
                for (const key in this.abilities) {
                    this.abilities[key].cd = Math.max(0, this.abilities[key].cd - dt);
                }

                // –î–≤–∏–∂–µ–Ω–∏–µ
                const dist = this.position.distanceTo(this.targetPosition);
                if (dist > 5) {
                    const direction = new Vector2(
                        this.targetPosition.x - this.position.x,
                        this.targetPosition.y - this.position.y
                    ).normalize();
                    this.position.x += direction.x * this.moveSpeed * (dt / 1000);
                    this.position.y += direction.y * this.moveSpeed * (dt / 1000);
                }

                // –ê–≤—Ç–æ-–∞—Ç–∞–∫–∞ (–µ—Å–ª–∏ –Ω–µ –¥–≤–∏–≥–∞–µ–º—Å—è)
                const closestEnemy = entities.filter(e => e.team !== TEAM_RADIANT && e.hp > 0 && !(e instanceof Tower))
                    .sort((a, b) => this.position.distanceTo(a.position) - this.position.distanceTo(b.position))[0];

                if (closestEnemy && this.position.distanceTo(closestEnemy.position) <= this.attackRange && dist < 5) {
                    if (this.attackCooldown === 0) {
                        this.attack(closestEnemy);
                        this.attackCooldown = 1200;
                    }
                }
                this.attackCooldown = Math.max(0, this.attackCooldown - dt);
            }

            // –ú–≥–Ω–æ–≤–µ–Ω–Ω—ã–µ —Å–ø–æ—Å–æ–±–Ω–æ—Å—Ç–∏ (Q, E, D)
            castAbility(key, targetPosition) {
                const ability = this.abilities[key];
                
                // –ü—Ä–æ–≤–µ—Ä–∫–∞ –¥–æ—Å—Ç—É–ø–Ω–æ—Å—Ç–∏ D
                if (!ability.available && key === 'D') {
                    showMessage('–°–ø–æ—Å–æ–±–Ω–æ—Å—Ç—å D –Ω–µ–¥–æ—Å—Ç—É–ø–Ω–∞. –ö—É–ø–∏—Ç–µ "–°–≤–∏—Ç–æ–∫ –ü—Ä–∏–∑—ã–≤–∞"', 'text-yellow-400');
                    return false;
                }
                
                // –ü—Ä–æ–≤–µ—Ä–∫–∞ –º–∞–Ω—ã –∏ –ö–î
                if (ability.cd > 0 || this.mana < ability.manaCost) {
                    showMessage(`–ù–µ —Ö–≤–∞—Ç–∞–µ—Ç –º–∞–Ω—ã –∏–ª–∏ —Å–ø–æ—Å–æ–±–Ω–æ—Å—Ç—å –Ω–µ –ø–µ—Ä–µ–∑–∞—Ä—è–¥–∏–ª–∞—Å—å. (–û—Å—Ç–∞–ª–æ—Å—å ${Math.ceil(ability.cd / 1000)}—Å)`, 'text-red-500');
                    return false;
                }
                if (this.isDead || this.isCasting) {
                    showMessage('–ì–µ—Ä–æ–π –∑–∞–Ω—è—Ç –∏ –Ω–µ –º–æ–∂–µ—Ç –∏—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å —Å–ø–æ—Å–æ–±–Ω–æ—Å—Ç–∏.', 'text-red-500');
                    return false;
                }

                this.mana -= ability.manaCost;
                ability.cd = ability.maxCd;
                
                // –î–ª—è Q, E, D: –≥–µ—Ä–æ–π –ø—Ä–æ–¥–æ–ª–∂–∞–µ—Ç –¥–≤–∏–≥–∞—Ç—å—Å—è (this.targetPosition –Ω–µ –º–µ–Ω—è–µ—Ç—Å—è)

                switch (key) {
                    case 'Q': // –ü–æ–ª–Ω–æ–µ –ò—Å—Ü–µ–ª–µ–Ω–∏–µ
                        this.hp = this.maxHp;
                        showMessage('Q: –ü–æ–ª–Ω–æ–µ –ò—Å—Ü–µ–ª–µ–Ω–∏–µ!', 'text-green-500');
                        break;
                    case 'E': // –ü—Ä–∏–∑—ã–≤ –°–æ—é–∑–Ω–∏–∫–æ–≤
                        const numAllies = 3;
                        for (let i = 0; i < numAllies; i++) {
                            const offset = 50;
                            const allyX = this.position.x + (Math.random() * offset) - (offset / 2);
                            const allyY = this.position.y + (Math.random() * offset) - (offset / 2);

                            entities.push(new AllyCreep({ x: allyX, y: allyY }));
                        }
                        showMessage(`E: –ü—Ä–∏–∑–≤–∞–Ω–æ ${numAllies} —Å–æ—é–∑–Ω–∏–∫–æ–≤, –Ω–∞—Ü–µ–ª–µ–Ω–Ω—ã—Ö –Ω–∞ –±–∞—à–Ω–∏!`, 'text-purple-400');
                        break;
                    case 'D': // –ü—Ä–∏–∑—ã–≤ –°–∏–ª—å–Ω–æ–≥–æ –°–æ—é–∑–Ω–∏–∫–∞
                        entities.push(new StrongAllyCreep({ x: this.position.x, y: this.position.y }));
                        showMessage('D: –ü—Ä–∏–∑–≤–∞–Ω –°–∏–ª—å–Ω—ã–π –°–æ—é–∑–Ω–∏–∫!', 'text-orange-400');
                        break;
                }
                return true;
            }

            // –ò—Å–ø–æ–ª–Ω–µ–Ω–∏–µ —Å–ø–æ—Å–æ–±–Ω–æ—Å—Ç–µ–π W –∏ R –ø–æ—Å–ª–µ –∑–∞–¥–µ—Ä–∂–∫–∏ –∫–∞—Å—Ç–∞
            executeCast(key, targetPosition) {
                if (key === 'W') { 
                    // W: –ú–µ—Ç–µ–æ—Ä –°–º–µ—Ä—Ç–∏
                    const AOE_RADIUS_W = 150;
                    const targetsW = entities.filter(e => e.team === TEAM_DIRE && targetPosition.distanceTo(e.position) < AOE_RADIUS_W && (e instanceof Creep || e instanceof AllyCreep));

                    targetsW.forEach(c => {
                        const isDead = c.takeDamage(99999);
                        if (isDead) this.onKill(c, true);
                    });

                    delayedEffects.push({
                        position: targetPosition,
                        radius: AOE_RADIUS_W,
                        // –ò–°–ü–†–ê–í–õ–ï–ù–ò–ï: –ò—Å–ø–æ–ª—å–∑—É–µ–º gameTime –≤–º–µ—Å—Ç–æ Date.now()
                        time: gameTime + 500, 
                        color: 'rgba(255, 100, 0, 0.9)',
                        type: 'meteor_strike'
                    });
                } else if (key === 'R') { 
                    // R: –£–ª—å—Ç–∏–º–∞—Ç–∏–≤–Ω—ã–π –£–¥–∞—Ä
                    const AOE_RADIUS_R = 200;
                    const TOWER_DMG = 500;
                    const HERO_CREEP_DMG = this.attackDamage * 5;

                    // –£—Ä–æ–Ω –ø–æ —Å—Ç—Ä—É–∫—Ç—É—Ä–∞–º
                    towers.filter(t => t.team === TEAM_DIRE && targetPosition.distanceTo(t.position) < AOE_RADIUS_R && t.hp > 0)
                        .forEach(t => t.takeDamage(TOWER_DMG));

                    if (targetPosition.distanceTo(DIRE_THRONE) < AOE_RADIUS_R + DIRE_THRONE.size) {
                         DIRE_THRONE.hp = Math.max(0, DIRE_THRONE.hp - TOWER_DMG);
                    }

                    // –£—Ä–æ–Ω –ø–æ —é–Ω–∏—Ç–∞–º
                    entities.filter(e => e.team !== TEAM_RADIANT && targetPosition.distanceTo(e.position) < AOE_RADIUS_R)
                        .forEach(e => e.takeDamage(HERO_CREEP_DMG));

                    delayedEffects.push({
                        position: targetPosition,
                        radius: AOE_RADIUS_R,
                        // –ò–°–ü–†–ê–í–õ–ï–ù–ò–ï: –ò—Å–ø–æ–ª—å–∑—É–µ–º gameTime –≤–º–µ—Å—Ç–æ Date.now()
                        time: gameTime + 1000,
                        color: 'rgba(0, 255, 255, 0.5)',
                        type: 'ultimate_strike'
                    });
                }
            }

            onKill(target, isLastHit) {
                const isNeutral = target.team === 'neutral';
                
                if (isNeutral) {
                    this.gold += target.goldValue;
                    this.exp += target.expValue;
                } else if (isLastHit) {
                    this.gold += target.goldValue;
                } else {
                    this.gold += Math.floor(target.goldValue / 5);
                }

                this.exp += target.expValue;
                this.checkLevelUp();
            }

            checkLevelUp() {
                if (this.exp >= this.expToNextLevel && this.level < 25) {
                    this.level++;
                    this.exp -= this.expToNextLevel;
                    this.expToNextLevel = Math.floor(this.expToNextLevel * 1.3);
                    this.maxHp += 80; this.maxMana += 50;
                    this.hp = this.maxHp; this.mana = this.maxMana;
                    this.attackDamage += 8;
                    showMessage(`–£—Ä–æ–≤–µ–Ω—å ${this.level}! –•–∞—Ä–∞–∫—Ç–µ—Ä–∏—Å—Ç–∏–∫–∏ —É–ª—É—á—à–µ–Ω—ã.`, 'text-blue-400');
                }
            }

            draw() {
                if (this.isDead) {
                    ctx.fillStyle = `rgba(255, 255, 255, 0.5)`;
                    ctx.font = '20px Inter';
                    ctx.textAlign = 'center';
                    ctx.fillText(`${Math.ceil(this.respawnTimer / 1000)}`, RADIANT_THRONE.x, RADIANT_THRONE.y + 10);
                    return;
                }

                ctx.fillStyle = '#00b0ff';
                ctx.beginPath();
                ctx.arc(this.position.x, this.position.y, this.radius, 0, Math.PI * 2);
                ctx.fill();

                ctx.strokeStyle = '#fff';
                ctx.lineWidth = 1;
                ctx.stroke();
                
                // –ò–Ω–¥–∏–∫–∞—Ç–æ—Ä –∫–∞—Å—Ç–∞
                if (this.isCasting) {
                    const progress = this.castTimer / 500; // 0.5s = 500ms
                    ctx.strokeStyle = '#ffcc00';
                    ctx.lineWidth = 3;
                    ctx.beginPath();
                    ctx.arc(this.position.x, this.position.y, this.radius + 5, 0, Math.PI * 2 * (1 - progress));
                    ctx.stroke();
                }

                this.drawHealthBar();
                this.drawManaBar();
            }

            drawManaBar() {
                const barWidth = this.radius * 2;
                const barHeight = 4;
                const manaRatio = this.mana / this.maxMana;

                ctx.fillStyle = 'black';
                ctx.fillRect(this.position.x - this.radius, this.position.y - this.radius - 2 * barHeight - 4, barWidth, barHeight);

                ctx.fillStyle = '#4299e1';
                ctx.fillRect(this.position.x - this.radius, this.position.y - this.radius - 2 * barHeight - 4, barWidth * manaRatio, barHeight);
            }

            attack(target) {
                let isDead;
                const targetIsCreep = target instanceof Creep;
                const targetIsNeutral = target.team === 'neutral';

                if (target.team === TEAM_DIRE || targetIsNeutral) {
                    isDead = target.takeDamage(this.attackDamage);

                    if (isDead) {
                        this.onKill(target, true);
                    } else if (targetIsCreep && target.hp < this.attackDamage) {
                         // –î–µ–Ω–∞–π –Ω–µ —Ä–µ–∞–ª–∏–∑–æ–≤–∞–Ω
                    } else {
                        this.onKill(target, false);
                    }
                } else if (target.team === TEAM_RADIANT && targetIsCreep) {
                    // –î–µ–Ω–∞–π
                    isDead = target.takeDamage(this.attackDamage);
                    if (isDead) {
                        this.exp += target.expValue / 2;
                        this.checkLevelUp();
                        showMessage('–î–µ–Ω–∞–π!', 'text-purple-400');
                    }
                }

                projectiles.push({
                    start: new Vector2(this.position.x, this.position.y),
                    end: new Vector2(target.position.x, target.position.y),
                    color: '#00b0ff',
                    time: 0,
                    duration: 100
                });
            }
        }

        // --- –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è ---

        function initializeGame() {
            // –°–±—Ä–æ—Å —Å–æ—Å—Ç–æ—è–Ω–∏—è
            gameActive = true;
            entities = [];
            projectiles = [];
            towers = [];
            delayedEffects = [];
            lastSpawnTime = 0;
            gameTime = 0; // –°–±—Ä–æ—Å –≤—Ä–µ–º–µ–Ω–∏ –∏–≥—Ä—ã
            
            DIRE_THRONE.hp = DIRE_THRONE.maxHp;
            RADIANT_THRONE.hp = RADIANT_THRONE.maxHp;

            towers = INITIAL_TOWERS.map(t => new Tower(t));

            // –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è –ì–µ—Ä–æ—è
            hero = new Hero({ x: RADIANT_THRONE.x, y: RADIANT_THRONE.y });
            entities.push(hero);
            
            // –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è –ù–µ–π—Ç—Ä–∞–ª—å–Ω—ã—Ö –∫—Ä–∏–ø–æ–≤ (—Å–≤–µ—Ä—Ö—É –∫–∞—Ä—Ç—ã, –≤ —Ü–µ–Ω—Ç—Ä–µ)
            entities.push(new NeutralCreep({ x: MAP_WIDTH / 2 - 50, y: MAP_HEIGHT / 4 }));
            entities.push(new NeutralCreep({ x: MAP_WIDTH / 2 + 50, y: MAP_HEIGHT / 4 }));
            
            // –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è UI
            populateShop();
            document.getElementById('restartButton').classList.add('hidden');
            document.getElementById('messageBox').style.display = 'none';

            if (typeof gameLoop === 'function') {
                requestAnimationFrame(gameLoop);
            } else {
                gameLoop(0);
            }
        }

        // --- –§—É–Ω–∫—Ü–∏–∏ –ú–∞–≥–∞–∑–∏–Ω–∞ ---
        const SHOP_ITEMS = [
            { id: 1, name: '–ë–æ—Ç–∏–Ω–∫–∏', cost: 450, stats: { moveSpeed: 25 }, desc: '+25 –∫ —Å–∫–æ—Ä–æ—Å—Ç–∏ –±–µ–≥–∞' },
            { id: 2, name: '–¢–∞–ª–∏—Å–º–∞–Ω', cost: 500, stats: { maxMana: 100, mana: 100, attackDamage: 5 }, desc: '+100 –ú–∞–Ω—ã, +5 –£—Ä–æ–Ω–∞' },
            { id: 3, name: '–ö–æ–ª—å—Ü–æ –ó–¥–æ—Ä–æ–≤—å—è', cost: 800, stats: { maxHp: 200, hp: 200 }, desc: '+200 –ó–¥–æ—Ä–æ–≤—å—è' },
            { id: 4, name: '–°–≤–∏—Ç–æ–∫ –ü—Ä–∏–∑—ã–≤–∞', cost: 1500, stats: { abilityD: true }, desc: '–î–∞–µ—Ç —Å–ø–æ—Å–æ–±–Ω–æ—Å—Ç—å "–°–∏–ª—å–Ω—ã–π –°–æ—é–∑–Ω–∏–∫" (D)' },
        ];

        function populateShop() {
            const shopItemsDiv = document.getElementById('shopItems');
            shopItemsDiv.innerHTML = '';
            SHOP_ITEMS.forEach(item => {
                const itemDiv = document.createElement('div');
                itemDiv.className = 'flex justify-between items-center bg-gray-600 p-2 rounded-md';
                itemDiv.innerHTML = `
                    <div>
                        <p class="font-bold">${item.name} <span class="text-xs text-gray-400">(${item.desc})</span></p>
                        <p class="text-yellow-400 text-sm">${item.cost} G</p>
                    </div>
                    <button onclick="buyItem(${item.id})" class="buy-button bg-green-500 hover:bg-green-600 text-white text-sm font-semibold py-1 px-3 rounded-md transition duration-150">–ö—É–ø–∏—Ç—å</button>
                `;
                shopItemsDiv.appendChild(itemDiv);
            });
        }

        function buyItem(itemId) {
            const item = SHOP_ITEMS.find(i => i.id === itemId);
            if (item && hero.gold >= item.cost) {
                hero.gold -= item.cost;
                hero.items.push(item.name);
                for (const stat in item.stats) {
                    if (stat === 'abilityD') {
                        hero.abilities.D.available = true;
                    } else {
                        hero[stat] += item.stats[stat];
                    }
                }
                showMessage(`${item.name} –∫—É–ø–ª–µ–Ω!`, 'text-lime-300');
                updateUI();
            } else if (item) {
                showMessage(`–ù–µ–¥–æ—Å—Ç–∞—Ç–æ—á–Ω–æ –∑–æ–ª–æ—Ç–∞ –¥–ª—è –ø–æ–∫—É–ø–∫–∏ ${item.name}!`, 'text-red-500');
            }
        }

        // --- –°–ø–∞–≤–Ω –∏ –ª–æ–≥–∏–∫–∞ –∫—Ä–∏–ø–æ–≤ ---

        function spawnCreepWave() {
            // –í–æ–ª–Ω–∞ –°–≤–µ—Ç–∞
            for (let i = 0; i < 3; i++) {
                entities.push(new Creep({
                    x: RADIANT_SPAWN.x,
                    y: RADIANT_SPAWN.y + (i - 1) * 10,
                    team: TEAM_RADIANT,
                    type: i < 2 ? 'melee' : 'range'
                }));
            }
            // –í–æ–ª–Ω–∞ –¢—å–º—ã
            for (let i = 0; i < 3; i++) {
                entities.push(new Creep({
                    x: DIRE_SPAWN.x,
                    y: DIRE_SPAWN.y + (i - 1) * 10,
                    team: TEAM_DIRE,
                    type: i < 2 ? 'melee' : 'range'
                }));
            }
            showMessage('–ö—Ä–∏–ø—ã –≤—ã—à–ª–∏ –Ω–∞ –ª–∏–Ω–∏—é!', 'text-gray-400');
        }

        // --- –û—Ç—Ä–∏—Å–æ–≤–∫–∞ –º–∏—Ä–∞ –∏ UI ---

        function drawMap() {
            // –§–æ–Ω –ª–∏–Ω–∏–∏
            ctx.fillStyle = '#1e293b';
            ctx.fillRect(0, LANE_Y - 20, MAP_WIDTH, 40);

            // –ì—Ä–∞–Ω–∏—Ü—ã
            ctx.strokeStyle = '#4c51bf';
            ctx.lineWidth = 3;
            ctx.beginPath();
            ctx.moveTo(0, LANE_Y - 20);
            ctx.lineTo(MAP_WIDTH, LANE_Y - 20);
            ctx.moveTo(0, LANE_Y + 20);
            ctx.lineTo(MAP_WIDTH, LANE_Y + 20);
            ctx.stroke();

            // –¢—Ä–æ–Ω –°–≤–µ—Ç–∞
            ctx.fillStyle = RADIANT_THRONE.color;
            ctx.fillRect(RADIANT_THRONE.x - RADIANT_THRONE.size / 2, RADIANT_THRONE.y - RADIANT_THRONE.size / 2, RADIANT_THRONE.size, RADIANT_THRONE.size);
            // –¢—Ä–æ–Ω –¢—å–º—ã
            ctx.fillStyle = DIRE_THRONE.color;
            ctx.fillRect(DIRE_THRONE.x - DIRE_THRONE.size / 2, DIRE_THRONE.y - DIRE_THRONE.size / 2, DIRE_THRONE.size, DIRE_THRONE.size);
        }

        function drawTowers() {
            towers.filter(t => t.hp > 0).forEach(t => t.draw());
            
            // –û—Ç—Ä–∏—Å–æ–≤–∫–∞ –∑–¥–æ—Ä–æ–≤—å—è –¢—Ä–æ–Ω–æ–≤
            const drawThroneHealth = (throne) => {
                const barWidth = 60;
                const barHeight = 8;
                const healthRatio = throne.hp / throne.maxHp;
                const x = throne.x - barWidth / 2;
                const y = throne.y - throne.size / 2 - barHeight - 5;

                ctx.fillStyle = 'black';
                ctx.fillRect(x, y, barWidth, barHeight);
                ctx.fillStyle = throne.team === TEAM_DIRE ? '#f56565' : '#48bb78';
                ctx.fillRect(x, y, barWidth * healthRatio, barHeight);
                
                ctx.fillStyle = 'white';
                ctx.font = '12px Inter';
                ctx.textAlign = 'center';
                ctx.fillText('–¢–†–û–ù', throne.x, y - 5);
            }
            drawThroneHealth(RADIANT_THRONE);
            drawThroneHealth(DIRE_THRONE);
        }

        function updateUI() {
            const statsDiv = document.getElementById('heroStats');
            statsDiv.innerHTML = `
                ${hero.isDead ? 
                    `<p class="text-red-500 font-bold">üíÄ –ú–µ—Ä—Ç–≤. –í–æ–∑—Ä–æ–∂–¥–µ–Ω–∏–µ —á–µ—Ä–µ–∑ ${Math.ceil(hero.respawnTimer / 1000)}—Å</p>` 
                    : `
                    <p>‚ù§Ô∏è –ó–¥–æ—Ä–æ–≤—å–µ: ${Math.floor(hero.hp)} / ${hero.maxHp}</p>
                    <p>üíß –ú–∞–Ω–∞: ${Math.floor(hero.mana)} / ${hero.maxMana}</p>
                `}
                <p>üí∞ –ó–æ–ª–æ—Ç–æ: <span class="text-yellow-400 font-semibold">${Math.floor(hero.gold)}</span></p>
                <p>‚≠ê –£—Ä–æ–≤–µ–Ω—å: <span class="text-blue-400 font-semibold">${hero.level}</span> (–û–ø—ã—Ç: ${hero.exp}/${hero.expToNextLevel})</p>
                <p>‚öîÔ∏è –£—Ä–æ–Ω: ${hero.attackDamage}</p>
                <p>üí® –°–∫–æ—Ä–æ—Å—Ç—å: ${hero.moveSpeed}</p>
                <p>üì¶ –ü—Ä–µ–¥–º–µ—Ç—ã: ${hero.items.length > 0 ? hero.items.join(', ') : '–ù–µ—Ç'}</p>
            `;

            // –û–±–Ω–æ–≤–ª–µ–Ω–∏–µ –ö–î —Å–ø–æ—Å–æ–±–Ω–æ—Å—Ç–µ–π
            for (const key in hero.abilities) {
                const btn = document.getElementById(`ability${key}`);
                const ability = hero.abilities[key];
                
                if (!btn) continue; // –ü—Ä–æ–ø—É—Å–∫–∞–µ–º, –µ—Å–ª–∏ –∫–Ω–æ–ø–∫–∏ –Ω–µ—Ç (–Ω–∞–ø—Ä–∏–º–µ—Ä, D –¥–æ –ø–æ–∫—É–ø–∫–∏)

                const cdSec = Math.ceil(ability.cd / 1000);
                
                if (key === 'D' && !ability.available) {
                    btn.disabled = true;
                    btn.innerHTML = key;
                    btn.title = 'D: –ü—Ä–∏–∑—ã–≤ –°–∏–ª—å–Ω–æ–≥–æ –°–æ—é–∑–Ω–∏–∫–∞ (–ù–µ –∫—É–ø–ª–µ–Ω–æ)';
                    continue;
                }
                
                // –ü—Ä–æ–≤–µ—Ä–∫–∞: –º–µ—Ä—Ç–≤, –∫–∞—Å—Ç—É–µ—Ç, –ö–î, –Ω–µ —Ö–≤–∞—Ç–∞–µ—Ç –º–∞–Ω—ã
                const isDisabled = hero.isDead || hero.isCasting || ability.cd > 0 || hero.mana < ability.manaCost;

                btn.disabled = isDisabled;

                // –û—Ç–æ–±—Ä–∞–∂–µ–Ω–∏–µ –ø–µ—Ä–µ–∑–∞—Ä—è–¥–∫–∏
                if (ability.cd > 0) {
                    btn.innerHTML = `<div class="cooldown-overlay">${cdSec}</div>${key}`;
                } 
                // –û—Ç–æ–±—Ä–∞–∂–µ–Ω–∏–µ –∏–Ω–¥–∏–∫–∞—Ç–æ—Ä–∞ –∫–∞—Å—Ç–∞
                else if (hero.isCasting && hero.pendingCast && hero.pendingCast.key === key) {
                     const castTimeLeft = (hero.castTimer / 500) * 100; // –ü—Ä–æ–≥—Ä–µ—Å—Å –æ—Ç 0 –¥–æ 100
                     btn.innerHTML = `<div class="cast-overlay" style="clip-path: inset(0% 0% ${castTimeLeft}% 0%);">${key}</div>`;
                }
                else {
                    btn.innerHTML = key;
                }
                
                // –û–±–Ω–æ–≤–ª–µ–Ω–∏–µ title –¥–ª—è –ø–æ–¥—Å–∫–∞–∑–æ–∫
                if (ability.cd > 0) {
                     btn.title = `${ability.desc} (–û—Å—Ç–∞–ª–æ—Å—å ${cdSec}—Å)`;
                } else if (hero.mana < ability.manaCost) {
                     btn.title = `${ability.desc} (–ù–µ–¥–æ—Å—Ç–∞—Ç–æ—á–Ω–æ –º–∞–Ω—ã)`;
                } else if (hero.isCasting) {
                     btn.title = `${ability.desc} (–ì–µ—Ä–æ–π –∑–∞–Ω—è—Ç)`;
                } else {
                     btn.title = ability.desc;
                }
            }
        }

        function showMessage(text, colorClass = 'text-white') {
            const msgBox = document.getElementById('messageBox');
            msgBox.textContent = text;
            msgBox.className = `ui-panel w-full text-center font-bold mt-4 ${colorClass}`;
            msgBox.style.display = 'block';
            clearTimeout(msgBox.timer);
            msgBox.timer = setTimeout(() => {
                msgBox.style.display = 'none';
            }, 3000);
        }

        // --- –ì–ª–∞–≤–Ω—ã–π –∏–≥—Ä–æ–≤–æ–π —Ü–∏–∫–ª ---
        function gameLoop(time) {
            if (!gameActive) {
                const winText = DIRE_THRONE.hp <= 0 ? '–ü–û–ë–ï–î–ê –°–í–ï–¢–ê!' : '–ü–û–ë–ï–î–ê –¢–¨–ú–´!';
                const winColor = DIRE_THRONE.hp <= 0 ? 'rgba(56, 161, 105, 0.8)' : 'rgba(229, 62, 62, 0.8)';
                
                ctx.fillStyle = winColor;
                ctx.fillRect(0, 0, MAP_WIDTH, MAP_HEIGHT);
                ctx.fillStyle = 'white';
                ctx.font = '48px Inter';
                ctx.textAlign = 'center';
                ctx.fillText(winText, MAP_WIDTH / 2, MAP_HEIGHT / 2);
                document.getElementById('restartButton').classList.remove('hidden');
                return;
            }

            const dt = time - lastTime;
            lastTime = time;
            gameTime += dt; // –ò–°–ü–†–ê–í–õ–ï–ù–ò–ï: –û–±–Ω–æ–≤–ª—è–µ–º —É–Ω–∏—Ñ–∏—Ü–∏—Ä–æ–≤–∞–Ω–Ω—ã–π —Å—á–µ—Ç—á–∏–∫ –≤—Ä–µ–º–µ–Ω–∏

            // 1. –û—á–∏—Å—Ç–∫–∞
            ctx.clearRect(0, 0, MAP_WIDTH, MAP_HEIGHT);

            // 2. –°–ø–∞–≤–Ω –∫—Ä–∏–ø–æ–≤
            if (gameTime - lastSpawnTime > SPAWN_INTERVAL) { // –ò–°–ü–†–ê–í–õ–ï–ù–ò–ï: –ò—Å–ø–æ–ª—å–∑—É–µ–º gameTime
                spawnCreepWave();
                lastSpawnTime = gameTime; // –ò–°–ü–†–ê–í–õ–ï–ù–ò–ï: –ò—Å–ø–æ–ª—å–∑—É–µ–º gameTime
            }

            // 3. –û–±–Ω–æ–≤–ª–µ–Ω–∏–µ –º–∏—Ä–∞
            hero.update(dt);
            towers.forEach(t => t.update(dt));
            entities.forEach(e => e.update(dt));
            updateProjectiles(dt);
            updateDelayedEffects(gameTime); // –ò–°–ü–†–ê–í–õ–ï–ù–ò–ï: –ü–µ—Ä–µ–¥–∞–µ–º gameTime
            
            // 4. –û—á–∏—Å—Ç–∫–∞ –º–µ—Ä—Ç–≤—ã—Ö
            entities = entities.filter(e => e.hp > 0 || e instanceof Hero);
            towers = towers.filter(t => t.hp > 0);

            // –ü—Ä–æ–≤–µ—Ä–∫–∞ –Ω–∞ –ø–æ–±–µ–¥—É/–ø–æ—Ä–∞–∂–µ–Ω–∏–µ (–¢—Ä–æ–Ω)
            if (DIRE_THRONE.hp <= 0) {
                gameActive = false;
            } else if (RADIANT_THRONE.hp <= 0) {
                gameActive = false;
            }

            // 5. –û—Ç—Ä–∏—Å–æ–≤–∫–∞
            drawMap();
            drawTowers();
            entities.forEach(e => e.draw());
            drawProjectiles();
            drawDelayedEffects(gameTime); // –ò–°–ü–†–ê–í–õ–ï–ù–ò–ï: –ü–µ—Ä–µ–¥–∞–µ–º gameTime

            // 6. –û–±–Ω–æ–≤–ª–µ–Ω–∏–µ UI
            updateUI();
            requestAnimationFrame(gameLoop);
        }

        // --- –î–æ–ø–æ–ª–Ω–∏—Ç–µ–ª—å–Ω—ã–µ —Ñ—É–Ω–∫—Ü–∏–∏ –¥–ª—è –æ—Ç—Ä–∏—Å–æ–≤–∫–∏ —ç—Ñ—Ñ–µ–∫—Ç–æ–≤ ---

        function updateProjectiles(dt) {
            projectiles = projectiles.filter(p => {
                p.time += dt;
                if (p.time < p.duration) {
                    const t = p.time / p.duration;
                    p.position = new Vector2(
                        p.start.x + (p.end.x - p.start.x) * t,
                        p.start.y + (p.end.y - p.start.y) * t
                    );
                    return true;
                }
                return false;
            });
        }

        function drawProjectiles() {
            projectiles.forEach(p => {
                ctx.fillStyle = p.color;
                ctx.beginPath();
                ctx.arc(p.position.x, p.position.y, 3, 0, Math.PI * 2);
                ctx.fill();
            });
        }

        function updateDelayedEffects(currentTime) {
            delayedEffects = delayedEffects.filter(effect => {
                if (currentTime >= effect.time) {
                    return false;
                }
                return true;
            });
        }

        function drawDelayedEffects(currentTime) {
            delayedEffects.forEach(effect => {
                // –ò–°–ü–†–ê–í–õ–ï–ù–ò–ï: –ò—Å–ø–æ–ª—å–∑—É–µ–º currentTime (gameTime) –¥–ª—è —Ä–∞—Å—á–µ—Ç–∞ –æ—Å—Ç–∞–≤—à–µ–≥–æ—Å—è –≤—Ä–µ–º–µ–Ω–∏
                const elapsed = effect.time - currentTime;
                const duration = effect.type === 'meteor_strike' ? 500 : 1000;
                // –ü—Ä–æ–≥—Ä–µ—Å—Å –æ—Ç 0 (–Ω–∞—á–∞–ª–æ) –¥–æ 1 (–∫–æ–Ω–µ—Ü)
                const progress = 1 - (elapsed / duration);

                // –†–∞–¥–∏—É—Å –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å –ø–æ–ª–æ–∂–∏—Ç–µ–ª—å–Ω—ã–º, –æ–≥—Ä–∞–Ω–∏—á–∏–≤–∞–µ–º –ø—Ä–æ–≥—Ä–µ—Å—Å –≤ –ø—Ä–µ–¥–µ–ª–∞—Ö [0, 1]
                const clampedProgress = Math.min(1, Math.max(0, progress));

                if (effect.type === 'meteor_strike') {
                    ctx.fillStyle = `rgba(255, 69, 0, 0.8)`;
                    ctx.beginPath();
                    ctx.arc(effect.position.x, effect.position.y, effect.radius * clampedProgress, 0, Math.PI * 2);
                    ctx.fill();
                } else if (effect.type === 'ultimate_strike') {
                    ctx.fillStyle = `rgba(0, 255, 255, 0.6)`;
                    ctx.beginPath();
                    ctx.arc(effect.position.x, effect.position.y, effect.radius * clampedProgress, 0, Math.PI * 2);
                    ctx.fill();
                }
                
                // –¢–µ–∫—Å—Ç –ø–æ–∫–∞–∑—ã–≤–∞–µ—Ç—Å—è —Ç–æ–ª—å–∫–æ –≤ –Ω–∞—á–∞–ª–µ –∫–∞—Å—Ç–∞ (–∫–æ–≥–¥–∞ elapsed –µ—â–µ –±–æ–ª—å—à–æ–π)
                if (elapsed > 0 && progress < 0.5) { 
                     ctx.fillStyle = 'white';
                     ctx.font = '16px Inter';
                     ctx.textAlign = 'center';
                     ctx.fillText(`–£–î–ê–†!`, effect.position.x, effect.position.y + 5);
                }
            });
        }


        // --- –û–±—Ä–∞–±–æ—Ç–∫–∞ –≤–≤–æ–¥–∞ ---

        let castingAbility = null; // –•—Ä–∞–Ω–∏—Ç –∫–ª—é—á —Å–ø–æ—Å–æ–±–Ω–æ—Å—Ç–∏ W/R, –æ–∂–∏–¥–∞—é—â–µ–π —Ü–µ–ª—å

        canvas.addEventListener('click', (e) => {
            const rect = canvas.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const y = e.clientY - rect.top;
            const clickPos = new Vector2(x, y);

            if (hero.isDead || hero.isCasting) return; // –ù–µ–ª—å–∑—è –∫–ª–∏–∫–∞—Ç—å, –µ—Å–ª–∏ –º–µ—Ä—Ç–≤ –∏–ª–∏ –∫–∞—Å—Ç—É–µ—à—å

            if (castingAbility) {
                // --- –õ–û–ì–ò–ö–ê –ù–ê–ß–ê–õ–ê –ö–ê–°–¢–ê W/R (–ø–æ—Å–ª–µ –∫–ª–∏–∫–∞ –ø–æ —Ü–µ–ª–∏) ---
                const key = castingAbility;
                const ability = hero.abilities[key];
                
                // –ü—Ä–µ–¥–≤–∞—Ä–∏—Ç–µ–ª—å–Ω–∞—è –ø—Ä–æ–≤–µ—Ä–∫–∞ (–ú–∞–Ω–∞/–ö–î)
                if (ability.cd > 0 || hero.mana < ability.manaCost) {
                    showMessage(`–ù–µ —Ö–≤–∞—Ç–∞–µ—Ç –º–∞–Ω—ã –∏–ª–∏ —Å–ø–æ—Å–æ–±–Ω–æ—Å—Ç—å –Ω–µ –ø–µ—Ä–µ–∑–∞—Ä—è–¥–∏–ª–∞—Å—å.`, 'text-red-500');
                    castingAbility = null;
                    return;
                }
                
                // –ó–∞–ø—É—Å–∫ –ø–æ—Å–ª–µ–¥–æ–≤–∞—Ç–µ–ª—å–Ω–æ—Å—Ç–∏ –∫–∞—Å—Ç–∞
                hero.mana -= ability.manaCost;
                ability.cd = ability.maxCd;
                
                hero.targetPosition = hero.position; // –û—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ–º –≥–µ—Ä–æ—è –Ω–∞ –≤—Ä–µ–º—è –∫–∞—Å—Ç–∞
                hero.isCasting = true;
                hero.castTimer = 500; // –ó–∞–¥–µ—Ä–∂–∫–∞ 0.5 —Å–µ–∫—É–Ω–¥—ã
                hero.pendingCast = { key: key, target: clickPos };

                castingAbility = null; // –°–±—Ä–∞—Å—ã–≤–∞–µ–º —Ä–µ–∂–∏–º –ø—Ä–∏—Ü–µ–ª–∏–≤–∞–Ω–∏—è
                showMessage(`–ù–∞—á–∞–ª–æ –ø—Ä–∏–º–µ–Ω–µ–Ω–∏—è ${key}... –ì–µ—Ä–æ–π —Å—Ç–æ–∏—Ç –Ω–∞ –º–µ—Å—Ç–µ.`, 'text-yellow-300');
            } else {
                // –î–≤–∏–∂–µ–Ω–∏–µ
                hero.targetPosition = clickPos;
            }
        });

        document.addEventListener('keydown', (e) => {
            const key = e.key.toUpperCase();
            if (['Q', 'W', 'E', 'R', 'D'].includes(key)) {
                e.preventDefault();
                const ability = hero.abilities[key];
                
                if (!ability || hero.isDead || hero.isCasting) return;

                if (key === 'W' || key === 'R') {
                    // W –∏ R —Ç—Ä–µ–±—É—é—Ç –≤—ã–±–æ—Ä–∞ —Ü–µ–ª–∏ -> –í–∫–ª—é—á–∞–µ–º —Ä–µ–∂–∏–º –ø—Ä–∏—Ü–µ–ª–∏–≤–∞–Ω–∏—è
                    if (ability.cd === 0 && hero.mana >= ability.manaCost) {
                        castingAbility = key;
                        showMessage(`–í—ã–±–µ—Ä–∏—Ç–µ –æ–±–ª–∞—Å—Ç—å –¥–ª—è –ø—Ä–∏–º–µ–Ω–µ–Ω–∏—è ${key} (0.5—Å –∑–∞–¥–µ—Ä–∂–∫–∞ –∫–∞—Å—Ç–∞ –ø–æ—Å–ª–µ –∫–ª–∏–∫–∞)`, 'text-blue-500');
                    } else {
                        showMessage(`–ù–µ —Ö–≤–∞—Ç–∞–µ—Ç –º–∞–Ω—ã –∏–ª–∏ —Å–ø–æ—Å–æ–±–Ω–æ—Å—Ç—å –Ω–µ –ø–µ—Ä–µ–∑–∞—Ä—è–¥–∏–ª–∞—Å—å. (–û—Å—Ç–∞–ª–æ—Å—å ${Math.ceil(ability.cd / 1000)}—Å)`, 'text-red-500');
                    }
                } else {
                    // Q, E –∏ D –ø—Ä–∏–º–µ–Ω—è—é—Ç—Å—è –º–≥–Ω–æ–≤–µ–Ω–Ω–æ
                    hero.castAbility(key, hero.position);
                }
            }
        });

        // –û–±—Ä–∞–±–æ—Ç–∫–∞ –∫–Ω–æ–ø–æ–∫ UI
        const setupAbilityButton = (id, key) => {
            document.getElementById(id).addEventListener('click', () => {
                const ability = hero.abilities[key];

                if (!ability.available && key === 'D') {
                    showMessage('–°–ø–æ—Å–æ–±–Ω–æ—Å—Ç—å D –Ω–µ–¥–æ—Å—Ç—É–ø–Ω–∞. –ö—É–ø–∏—Ç–µ "–°–≤–∏—Ç–æ–∫ –ü—Ä–∏–∑—ã–≤–∞"', 'text-yellow-400');
                    return;
                }
                
                if (hero.isDead || hero.isCasting || ability.cd > 0 || hero.mana < ability.manaCost) return;


                if (key === 'W' || key === 'R') {
                    castingAbility = key;
                    showMessage(`–í—ã–±–µ—Ä–∏—Ç–µ –æ–±–ª–∞—Å—Ç—å –¥–ª—è –ø—Ä–∏–º–µ–Ω–µ–Ω–∏—è ${key} (0.5—Å –∑–∞–¥–µ—Ä–∂–∫–∞ –∫–∞—Å—Ç–∞ –ø–æ—Å–ª–µ –∫–ª–∏–∫–∞)`, 'text-blue-500');
                } else {
                    hero.castAbility(key, hero.position);
                }
            });
        };

        setupAbilityButton('abilityQ', 'Q');
        setupAbilityButton('abilityW', 'W');
        setupAbilityButton('abilityE', 'E');
        setupAbilityButton('abilityR', 'R');
        setupAbilityButton('abilityD', 'D');

        function restartGame() {
            initializeGame();
        }

        // –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è –∏–≥—Ä—ã –ø—Ä–∏ –∑–∞–≥—Ä—É–∑–∫–µ —Å—Ç—Ä–∞–Ω–∏—Ü—ã
        window.onload = function() {
            initializeGame();
        }

    </script>
</body>
</html>
